# 数据库系统

## 事务
事务指满足**ACID**特性的一组操作，可以通过 commit 提交事务，也可以通过  rollback 回滚事务。

### ACID
#### 1. 原子性(Atomicity)
事务被视为不可分割的最小单元，事务的所有操作要么全部提交，要么全部失败回滚。

#### 2. 一致性(Consistency)
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

#### 3. 隔离性(Isolation)
一个事务所做的修改在事务提交前，对其它事务不可见。

#### 4. 持久性(Durability)
一旦事务提交，则其所做的修改将永久保存到数据库中。即使系统发生崩溃也不能丢失。


## 并发一致性
在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

### 丢失修改
T1 和 T2 两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。

### 脏读
T1先修改， T2读取，随后T1撤消了修改，则T2读取的数据就是脏数据。

### 不可重复读
T2读取一个数据，T1随后修改，如果T2再次读取该数据，则与第一次读取的结果不同。

### 幻影读
T1读取了一定范围的一批数据，T2随后插入了新的数据，T1读取同一范围的一批数据，两批数据结果不同。

产生并发一致性问题的主要原因是破坏了事务的隔离性。并发控制需要加锁，但加锁需要自己控制，比较复杂，所以数据库管理系统提供了事务的隔离级别，以一种相对轻松的方式处理一致性问题。

## 锁类型
锁一般有表级锁和行级锁。

### 读写锁

* 排它锁（Exclusive），简写成 X 锁，又称写锁。
* 共享锁（Shared），简写成 S 锁，又称读锁。

有两个规定
* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不对 A 加任何锁。
* 一个事务对数据对象 A 加了 S 锁，就可以对 A 进行读取，但不能更新。加锁期间其它事务能对 A 加 S 锁，但不能加 X 锁。

锁的兼容关系

| -  | X  | S  |
|----|----|----|
| X  | n  | n  |
| S  | n  | y  |

### 意向锁
意向锁（Intention Locks）支持多粒度锁控制。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是**表锁**，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

锁的兼容关系
| -  | X  | IX | S  | IS |
|----|----|----|----|----|
| X  | n  | n  | n  | n  |
| IX | n  | y  | n  | y  |
| S  | n  | n  | y  | y  |
| IS | n  | y  | y  | y  |

解释如下：

* 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁。
* S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

## 隔离级别

### 未提交读（Read Uncommitted）
事务中的修改，即使没有提交，对其它事务也是可见的。

### 提交读（Read Committed）
一个事务所做的修改在提交之前，对其它事务不可见。

### 可重复读（Repeatable Read）
保证在同一个事务中多次读取同样的数据的结果是一样的。

### 可串行化（Serializable）
强制事务串行执行。

|隔离级别|脏读|不可重复读|幻影读|加锁读|
|----|----|----|----|----|
|未提交读| y | y | y | n |
|提交读 | n | y | y | n |
|可重复读| n | n | y | n |
|串行化| n | n | n | y |
